import * as XLSX from "xlsx";
import Papa from "papaparse"; // Import papaparse
import { supabase } from "@/lib/supabaseClient";
import {
  processDEV,
  processInterBR,
  processInterBRAccount,
  processHandelsbanken,
  processAmex,
  processSEB,
} from "@/lib/utils/bankProcessors";

export async function uploadExcel(file: File, bank: string) {
  try {
    console.log("uploadExcel called with bank:", bank, "file:", file.name);
    const arrayBuffer = await file.arrayBuffer();
    let data: string[][]; // Explicitly type data as string[][]

    if (file.name.endsWith(".csv")) {
      const text = new TextDecoder("utf-8").decode(arrayBuffer);

      // Use PapaParse to parse the CSV data
      const parsed = Papa.parse<string[]>(text, {
        header: false, // Disable header row parsing
        skipEmptyLines: true, // Skip empty lines
        delimiter: bank === "Inter-BR-Account" ? ";" : ",", // Use semicolon for Inter BR Account files
      });
      data = parsed.data as string[][]; // Cast parsed data to string[][]
    } else {
      const workbook = XLSX.read(arrayBuffer, { type: "array" });
      const sheetName = workbook.SheetNames[0];
      data = XLSX.utils.sheet_to_json<string[]>(workbook.Sheets[sheetName], {
        header: 1,
      }) as string[][]; // Cast to string[][]
    }
    console.log("Parsed data:", data.slice(0, 5)); // Log first 5 rows
    let processedData;
    console.log("Processing bank:", bank);
    switch (bank) {
      case "DEV":
        processedData = processDEV(data);
        console.log("Processed Data:", processedData);
        break;
      case "Inter-BR":
        processedData = processInterBR(data, file.name);
        break;
      case "Inter-BR-Account":
        console.log("Processing Inter-BR-Account");
        processedData = processInterBRAccount(data, file.name);
        console.log("Processed data:", processedData);
        break;
      case "Handelsbanken-SE":
        processedData = processHandelsbanken(data);
        break;
      case "AmericanExpress-SE":
        processedData = processAmex(data, file.name);
        break;
      case "SEB_SJ_Prio-SE":
        processedData = processSEB(data, file.name);
        break;
      default:
        return {
          success: false,
          error: "UNSUPPORTED_BANK",
          message: "Unknown bank type.",
        };
    }
    console.log("Final processed data:", processedData);
    // Upload to Supabase
    console.log("Uploading to Supabase table:", processedData.tableName);
    const result = await uploadToSupabase(
      processedData.tableName,
      processedData.transactions,
    );
    console.log("Upload result:", result);
    return result;
  } catch (error) {
    console.error("Error in uploadExcel:", error);
    return {
      success: false,
      error: "PROCESSING_ERROR",
      message:
        error instanceof Error ? error.message : "Unknown error occurred",
    };
  }
}

export async function createTableInSupabase(tableName: string) {
  // Since we can't execute DDL directly through the client, we'll return instructions
  const instructions = `Please create the table manually in your Supabase SQL editor with the following commands:

1. Create the table:
CREATE TABLE public."${tableName}" (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  "Date" date NULL,
  "Description" text NULL,
  "Amount" numeric NULL,
  "Balance" numeric NULL,
  "Category" text NULL DEFAULT 'Unknown'::text,
  "Responsible" text NULL DEFAULT 'Carlos'::text,
  "Comment" text NULL,
  user_id uuid NULL DEFAULT '2b5c5467-04e0-4820-bea9-1645821fa1b7'::uuid,
  "Bank" text NULL DEFAULT 'Inter-BR'::text,
  CONSTRAINT "${tableName}_pkey" PRIMARY KEY (id),
  CONSTRAINT "${tableName}_id_key" UNIQUE (id)
) TABLESPACE pg_default;

2. Enable RLS:
ALTER TABLE public."${tableName}" 
ENABLE ROW LEVEL SECURITY;

3. Create RLS Policy:
CREATE POLICY "Enable all for users based on user_id"
ON "public"."${tableName}"
AS PERMISSIVE
FOR ALL
TO authenticated
USING (
  (( SELECT auth.uid() AS uid) = user_id)
)
WITH CHECK (
  (SELECT auth.uid()) = user_id
);`;

  return instructions;
}

export async function executeTableCreation(tableName: string) {
  try {
    console.log("Attempting to create table:", tableName);

    // First, try to create the table using a direct SQL query
    // Note: This requires the user to have proper permissions and might not work in all Supabase configurations
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS public."${tableName}" (
        id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        created_at timestamp with time zone NOT NULL DEFAULT now(),
        "Date" date NULL,
        "Description" text NULL,
        "Amount" numeric NULL,
        "Balance" numeric NULL,
        "Category" text NULL DEFAULT 'Unknown'::text,
        "Responsible" text NULL DEFAULT 'Carlos'::text,
        "Comment" text NULL,
        user_id uuid NULL DEFAULT '2b5c5467-04e0-4820-bea9-1645821fa1b7'::uuid,
        "Bank" text NULL DEFAULT 'Inter-BR'::text,
        CONSTRAINT "${tableName}_pkey" PRIMARY KEY (id),
        CONSTRAINT "${tableName}_id_key" UNIQUE (id)
      );
      
      ALTER TABLE public."${tableName}" ENABLE ROW LEVEL SECURITY;
      
      CREATE POLICY IF NOT EXISTS "Enable all for users based on user_id"
      ON "public"."${tableName}"
      AS PERMISSIVE
      FOR ALL
      TO authenticated
      USING (
        (( SELECT auth.uid() AS uid) = user_id)
      )
      WITH CHECK (
        (SELECT auth.uid()) = user_id
      );
    `;
    // Try using the Supabase SQL function if available
    const { error } = await supabase.rpc("exec_sql", {
      sql: createTableSQL,
    });
    if (error) {
      // If exec_sql doesn't exist, try alternative approaches
      if (
        error.message.includes("function") ||
        error.message.includes("exec_sql") ||
        error.code === "42883"
      ) {
        console.log(
          "exec_sql function not available, trying alternative approach...",
        );

        // Alternative: Try to create by inserting into a test query
        // This is a fallback that might not work in all cases
        const testQuery = await supabase.from(tableName).select("*").limit(0);

        if (
          testQuery.error &&
          (testQuery.error.code === "42P01" ||
            testQuery.error.code === "PGRST116")
        ) {
          // Table still doesn't exist, return instructions for manual creation
          return {
            success: false,
            message:
              "Automatic table creation is not available. Please create the table manually using the SQL commands provided.",
            requiresManualCreation: true,
          };
        }
      } else {
        throw new Error(`Database error: ${error.message}`);
      }
    }

    // Verify the table was created successfully
    const verifyQuery = await supabase.from(tableName).select("id").limit(1);

    if (
      verifyQuery.error &&
      (verifyQuery.error.code === "42P01" ||
        verifyQuery.error.code === "PGRST116")
    ) {
      return {
        success: false,
        message:
          "Table creation failed. Please create the table manually using the SQL commands provided.",
        requiresManualCreation: true,
      };
    }

    console.log("Table created and verified successfully:", tableName);
    return {
      success: true,
      message: `Table "${tableName}" created successfully with RLS enabled!`,
    };
  } catch (error) {
    console.error("Error in executeTableCreation:", error);
    return {
      success: false,
      message:
        error instanceof Error ? error.message : "Unknown error occurred",
      requiresManualCreation: true,
    };
  }
}

async function uploadToSupabase(
  tableName: string,
  transactions: Record<string, unknown>[],
) {
  try {
    console.log("uploadToSupabase called with table:", tableName);
    console.log("Transaction count:", transactions.length);

    // Get the current highest ID from the table
    console.log("Checking if table exists...");
    const { data: maxIdData, error: maxIdError } = await supabase
      .from(tableName)
      .select("id")
      .order("id", { ascending: false })
      .limit(1);

    console.log("maxIdError:", maxIdError);
    if (maxIdError) {
      console.log("Error code:", maxIdError.code);
      console.log("Error message:", maxIdError.message);
    }
    if (
      maxIdError &&
      (maxIdError.code === "PGRST116" || maxIdError.code === "42P01")
    ) {
      // PGRST116 = table doesn't exist (PostgREST error)
      // 42P01 = relation does not exist (PostgreSQL error)
      console.log("Table doesn't exist, returning TABLE_NOT_EXISTS result");
      return {
        success: false,
        error: "TABLE_NOT_EXISTS",
        tableName: tableName,
        message: `Table "${tableName}" does not exist and needs to be created`,
      };
    } else if (maxIdError) {
      console.log("Other error occurred:", maxIdError.message);
      return {
        success: false,
        error: "DATABASE_ERROR",
        message: maxIdError.message,
      };
    }

    console.log("Table exists, proceeding with upload...");
    // Calculate the starting ID for new records
    const currentMaxId =
      maxIdData && maxIdData.length > 0 ? maxIdData[0].id : 0;

    // Update transaction IDs to continue from the current max
    const transactionsWithCorrectIds = transactions.map(
      (transaction, index) => ({
        ...transaction,
        id: currentMaxId + index + 1,
      }),
    );

    const { error } = await supabase
      .from(tableName)
      .insert(transactionsWithCorrectIds);

    if (error) {
      return {
        success: false,
        error: "INSERT_ERROR",
        message: error.message,
      };
    }

    return {
      success: true,
      message: `Upload successful! ${transactionsWithCorrectIds.length} records inserted into ${tableName} starting from ID ${currentMaxId + 1}`,
    };
  } catch (error) {
    console.error("Error in uploadToSupabase:", error);
    return {
      success: false,
      error: "UNEXPECTED_ERROR",
      message:
        error instanceof Error ? error.message : "Unknown error occurred",
    };
  }
}
