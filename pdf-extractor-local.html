<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Browser PDF Text Extractor (pdf.js)</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          Arial;
        margin: 24px;
      }
      .controls {
        margin-bottom: 12px;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .btn {
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #f7f7f7;
      }
      .btn.primary {
        background: #0070f3;
        color: white;
        border-color: #005ac1;
      }
      #output {
        white-space: pre-wrap;
        background: #111;
        color: #eee;
        padding: 12px;
        border-radius: 6px;
        min-height: 200px;
        overflow: auto;
      }
      #progress {
        font-size: 0.95rem;
        color: #333;
      }
      .password-overlay {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
      }
      .pw-box {
        background: white;
        padding: 18px;
        border-radius: 8px;
        width: 320px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
      }
      .pw-box label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
      }
      .pw-box input {
        width: 100%;
        padding: 8px;
        margin-bottom: 8px;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>Browser PDF Text Extractor (pdf.js)</h1>
    <p>
      Upload a PDF file. If it is password-protected, you'll be asked for the
      password. Extraction runs entirely in the browser.
    </p>

    <div class="controls">
      <input id="file-input" type="file" accept="application/pdf" />
      <button id="extract-btn" class="btn primary">Extract Text</button>
      <button id="download-btn" class="btn" disabled>Download .txt</button>
      <button id="show-page3-btn" class="btn" disabled>Show Page 3</button>
      <span id="progress">Ready</span>
      <button id="extract-page3-btn" class="btn" disabled>
        Extract from Page 3
      </button>
      <button id="extract-page3-7102-btn" class="btn" disabled>
        Extract from Page 3 (7102)
      </button>
    </div>

    <div id="output" aria-live="polite">No text extracted yet.</div>

    <!-- Dedicated area to display only the content of page 3 -->
    <h3>Page 3</h3>
    <div
      id="page3-output"
      aria-live="polite"
      style="
        white-space: pre-wrap;
        background: #fff;
        color: #111;
        padding: 12px;
        border-radius: 6px;
        min-height: 120px;
        border: 1px solid #ddd;
      "
    >
      No page 3 content yet.
    </div>
    <h4>Extracted snippet from Page 3</h4>
    <div
      id="page3-extract-output"
      aria-live="polite"
      style="
        white-space: pre-wrap;
        background: #f6f9ff;
        color: #072;
        padding: 12px;
        border-radius: 6px;
        min-height: 80px;
        border: 1px solid #cde;
      "
    >
      No snippet extracted yet.
    </div>
    <h4>Extracted snippet from Page 3 (card ...7102)</h4>
    <div
      id="page3-extract-output-7102"
      aria-live="polite"
      style="
        white-space: pre-wrap;
        background: #fff7f0;
        color: #572;
        padding: 12px;
        border-radius: 6px;
        min-height: 80px;
        border: 1px solid #f0d;
      "
    >
      No snippet extracted yet.
    </div>
    <h4>Structured JSON</h4>
    <pre
      id="page3-json-output"
      style="
        white-space: pre-wrap;
        background: #f0f0f3;
        padding: 12px;
        border-radius: 6px;
        min-height: 120px;
        border: 1px solid #ddd;
      "
    >
No JSON yet.</pre
    >

    <!-- Password prompt overlay (hidden until needed) -->
    <div
      id="password-overlay"
      class="password-overlay hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="pw-box">
        <form id="password-form">
          <label for="pdf-password">PDF Password</label>
          <input
            id="pdf-password"
            type="password"
            autocomplete="current-password"
          />
          <div style="display: flex; gap: 8px; justify-content: flex-end">
            <button type="button" id="pw-cancel" class="btn">Cancel</button>
            <button type="submit" class="btn primary">Submit</button>
          </div>
          <p
            id="pw-message"
            style="
              color: #b00020;
              margin-top: 8px;
              font-size: 0.95rem;
              display: none;
            "
          ></p>
        </form>
      </div>
    </div>

    <!-- pdf.js from CDN (use jsDelivr to avoid MIME/type issues when opening file://) -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist/build/pdf.min.js"></script>
    <script>
      // Simple, self-contained PDF text extractor using pdf.js in the browser.
      // Works with password-protected PDFs: detects password requirement and prompts user.

      const fileInput = document.getElementById("file-input");
      const extractBtn = document.getElementById("extract-btn");
      const progressEl = document.getElementById("progress");
      const output = document.getElementById("output");
      const downloadBtn = document.getElementById("download-btn");
      const showPage3Btn = document.getElementById("show-page3-btn");
      const extractPage3Btn = document.getElementById("extract-page3-btn");
      const extractPage3Btn7102 = document.getElementById(
        "extract-page3-7102-btn",
      );
      const page3Output = document.getElementById("page3-output");
      const page3ExtractOutput = document.getElementById(
        "page3-extract-output",
      );
      const page3ExtractOutput7102 = document.getElementById(
        "page3-extract-output-7102",
      );
      const page3JsonOutput = document.getElementById("page3-json-output");

      function setProgress(msg) {
        if (progressEl) progressEl.textContent = msg;
      }

      let pageTexts = [];
      let extractedText = "";

      const pwOverlay = document.getElementById("password-overlay");
      const pwForm = document.getElementById("password-form");
      const pwInput = document.getElementById("pdf-password");
      const pwCancel = document.getElementById("pw-cancel");
      const pwMessage = document.getElementById("pw-message");

      // point workerSrc to the CDN worker file (use jsDelivr to avoid MIME issues)
      if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdn.jsdelivr.net/npm/pdfjs-dist/build/pdf.worker.min.js";
      } else {
        console.error("pdfjsLib not found. Library failed to load.");
        // show a user-friendly message and disable interaction
        document.getElementById("progress").textContent =
          "Failed to load pdf.js library. See console for details.";
        const btn = document.getElementById("extract-btn");
        if (btn) btn.disabled = true;
      }

      // tolerant 'Subtotal' regex: allow optional spaces between letters (e.g. "S u btotal")
      const SUBTOTAL_REGEX = /S\s*u\s*b\s*t\s*o\s*t\s*a\s*l/i;

      let latestArrayBuffer = null;

      fileInput.addEventListener("change", (ev) => {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = () => {
          latestArrayBuffer = reader.result;
          setProgress(
            `Loaded file ${f.name} (${Math.round(f.size / 1024)} KB)`,
          );
        };
        reader.onerror = () => {
          setProgress("Error reading file");
        };
        reader.readAsArrayBuffer(f);
      });

      extractBtn.addEventListener("click", async () => {
        if (!latestArrayBuffer) {
          alert("No PDF selected.");
          return;
        }
        extractedText = "";
        pageTexts = [];
        showPage3Btn.disabled = true;
        if (extractPage3Btn) extractPage3Btn.disabled = true;
        if (extractPage3Btn7102) extractPage3Btn7102.disabled = true;
        output.textContent = "Extracting...";
        setProgress("Starting extraction...");

        try {
          await tryOpenAndExtract(latestArrayBuffer);
        } catch (err) {
          console.error(err);
          setProgress("Extraction failed");
          output.textContent =
            "Error: " + (err && err.message ? err.message : String(err));
        }
      });

      downloadBtn.addEventListener("click", () => {
        const blob = new Blob([extractedText], {
          type: "text/plain;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "extracted-text.txt";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      // Show only page 3 content when clicked
      showPage3Btn.addEventListener("click", () => {
        if (pageTexts && pageTexts.length >= 3) {
          page3Output.textContent = pageTexts[2] || "[page 3 has no text]";
        } else if (pageTexts && pageTexts.length > 0) {
          page3Output.textContent = "[page 3 not available in this PDF]";
        } else {
          page3Output.textContent = "[no extracted pages yet]";
        }
      });

      // Helper: extract snippet for specific card 4998****2091 (name - masked card -> until 'Subtotal')
      function extractSnippet2091FromText(text) {
        if (!text) {
          if (page3ExtractOutput)
            page3ExtractOutput.textContent = "[no text available for page 3]";
          return;
        }
        const normalized = text.replace(/\r/gi, "");
        // match the exact structure: name, dash, 4998, asterisks, ending 2091
        const specificRegex = /CARLOS\s+A\s+S\s+VELOSO\s*-\s*4998\*+2091/i;
        const match = specificRegex.exec(normalized);
        if (!match) {
          if (page3ExtractOutput)
            page3ExtractOutput.textContent =
              "[pattern 4998****2091 not found on page 3]";
          return;
        }
        const startIndex = match.index;
        const afterMatch = normalized.substring(startIndex + match[0].length);
        const subtotalMatch = SUBTOTAL_REGEX.exec(afterMatch);
        let endIndex;
        if (subtotalMatch) {
          endIndex = startIndex + match[0].length + subtotalMatch.index;
        } else {
          endIndex = normalized.length;
        }
        const snippet = normalized.substring(startIndex, endIndex).trim();
        if (page3ExtractOutput)
          page3ExtractOutput.textContent =
            snippet || "[extracted snippet empty]";
      }

      // Helper: extract snippet for 4998****7102 pattern
      function extractSnippet7102FromText(text) {
        if (!text) {
          if (page3ExtractOutput7102)
            page3ExtractOutput7102.textContent =
              "[no text available for page 3]";
          return;
        }
        const normalized = text.replace(/\r/gi, "");
        const specificRegex = /CARLOS\s+A\s+S\s+VELOSO\s*-\s*4998\*+7102/i;
        const match = specificRegex.exec(normalized);
        if (!match) {
          if (page3ExtractOutput7102)
            page3ExtractOutput7102.textContent =
              "[pattern 4998****7102 not found on page 3]";
          return;
        }
        const startIndex = match.index;
        const afterMatch = normalized.substring(startIndex + match[0].length);
        const subtotalMatch = SUBTOTAL_REGEX.exec(afterMatch);
        let endIndex;
        if (subtotalMatch) {
          endIndex = startIndex + match[0].length + subtotalMatch.index;
        } else {
          endIndex = normalized.length;
        }
        const snippet = normalized.substring(startIndex, endIndex).trim();
        if (page3ExtractOutput7102)
          page3ExtractOutput7102.textContent =
            snippet || "[extracted snippet empty]";
      }

      // Parse a snippet into records: find segments starting with a date and extract Data, Descrição, R$, US$
      function parseSnippetToRecords(snippet) {
        if (!snippet) return [];
        // Normalize whitespace and line breaks
        const norm = snippet
          .replace(/\r/g, "")
          .replace(/\t/g, " ")
          .replace(/\n+/g, "\n")
          .trim();
        // Find positions of date tokens (dd/mm/yy or dd/mm/yyyy)
        const dateRegex = /\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/g;
        const dates = [];
        let m;
        while ((m = dateRegex.exec(norm)) !== null) {
          dates.push({ idx: m.index, text: m[0] });
        }
        const records = [];
        if (dates.length === 0) return records;
        for (let i = 0; i < dates.length; i++) {
          const start = dates[i].idx;
          const end = i + 1 < dates.length ? dates[i + 1].idx : norm.length;
          const segment = norm.substring(start, end).trim();
          const dateMatch = segment.match(/\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/);
          const date = dateMatch ? dateMatch[0] : "";
          // amounts like 1.234,56 or 123,45 or -123,45
          const amountRegex = /-?\d{1,3}(?:[\.\s]\d{3})*[,\.]\d{2}/g;
          const amounts = (segment.match(amountRegex) || []).map((a) =>
            a.replace(/\s/g, ""),
          );
          // description = segment minus date and amounts
          let desc = segment.replace(date, "").trim();
          for (const a of amounts) desc = desc.replace(a, "").trim();
          desc = desc
            .replace(/^[-–—\s]+/, "")
            .replace(/\s+[-–—]$/, "")
            .trim();
          let rVal = "";
          let usVal = "";
          if (amounts.length >= 2) {
            rVal = amounts[0];
            usVal = amounts[1];
          } else if (amounts.length === 1) {
            rVal = amounts[0];
          }
          records.push({ Data: date, Descrição: desc, R$: rVal, US$: usVal });
        }
        return records;
      }

      // Build structured JSON object for both card snippets and render into the JSON output area
      function buildStructuredJSON() {
        const keyDefault = "CARLOS A S VELOSO - 4998********2091";
        const key7102 = "CARLOS A S VELOSO - 4998********7102";
        const snipDefault =
          (page3ExtractOutput && page3ExtractOutput.textContent) || "";
        const snip7102 =
          (page3ExtractOutput7102 && page3ExtractOutput7102.textContent) || "";
        const obj = {};
        obj[keyDefault] = parseSnippetToRecords(snipDefault);
        obj[key7102] = parseSnippetToRecords(snip7102);
        const pretty = JSON.stringify(obj, null, 2);
        const jsonOut = document.getElementById("page3-json-output");
        if (jsonOut) jsonOut.textContent = pretty;
        return obj;
      }

      // Extract snippet from page 3: find the name + card pattern and capture until 'Subtotal' (exclusive)
      if (extractPage3Btn) {
        extractPage3Btn.addEventListener("click", () => {
          const text = (pageTexts && pageTexts[2]) || "";
          if (!text) {
            if (page3ExtractOutput)
              page3ExtractOutput.textContent = "[no text available for page 3]";
            return;
          }

          // Normalize CR chars and prepare for case-insensitive searches
          const normalized = text.replace(/\r/gi, "");
          const nameRegex = /CARLOS\s+A\s+S\s+VELOSO/i;
          const nameMatch = nameRegex.exec(normalized);
          if (!nameMatch) {
            if (page3ExtractOutput)
              page3ExtractOutput.textContent = "[pattern not found on page 3]";
            return;
          }

          const startIndex = nameMatch.index;
          // Search for 'Subtotal' after the match (case-insensitive)
          const afterMatch = normalized.substring(
            startIndex + nameMatch[0].length,
          );
          const subtotalMatch = SUBTOTAL_REGEX.exec(afterMatch);
          let endIndex;
          if (subtotalMatch) {
            endIndex = startIndex + nameMatch[0].length + subtotalMatch.index;
          } else {
            endIndex = normalized.length;
          }

          const snippet = normalized.substring(startIndex, endIndex).trim();
          if (page3ExtractOutput)
            page3ExtractOutput.textContent =
              snippet || "[extracted snippet empty]";
          try {
            buildStructuredJSON();
          } catch (e) {
            console.error("buildStructuredJSON failed", e);
          }
        });
      }

      // Core flow: try opening with no password, if password required show prompt and retry.
      async function tryOpenAndExtract(arrayBuffer, providedPassword) {
        setProgress("Opening PDF...");
        // Create a fresh copy of the ArrayBuffer for pdf.js to consume.
        // pdf.js may transfer (and therefore detach) an ArrayBuffer when using a worker;
        // passing a copy prevents the original buffer from becoming detached and
        // allows retrying (e.g. after an incorrect password) without re-reading the file.
        const uint8 = new Uint8Array(arrayBuffer);
        const dataCopy = uint8.slice().buffer; // slice() creates a new copy
        const loadingTask = pdfjsLib.getDocument({
          data: dataCopy,
          password: providedPassword,
        });

        try {
          const pdf = await loadingTask.promise;
          setProgress(
            `PDF opened — ${pdf.numPages} page(s). Extracting text...`,
          );
          await extractAllText(pdf);
          setProgress("Extraction complete");
          output.textContent = extractedText || "[no text found]";
          downloadBtn.disabled = extractedText.length === 0;
          return;
        } catch (err) {
          // pdf.js uses PasswordException when PDF requires or rejects a password.
          // The error may contain 'Password' in its message; check robustly.
          const msg = (err && (err.message || err.toString())) || "";
          const needsPassword =
            /password/i.test(msg) || (err && err.name === "PasswordException");
          if (needsPassword) {
            // If user already provided a password, it must be incorrect.
            if (providedPassword) {
              await promptPassword("Incorrect password — please try again");
              return; // prompt handler will call tryOpenAndExtract again
            }
            // Show prompt to ask for password
            await promptPassword();
            return; // prompt handler will continue
          }
          // Other errors: rethrow
          throw err;
        }
      }

      // Extract snippet for the specific card pattern ending with 7102
      if (extractPage3Btn7102) {
        extractPage3Btn7102.addEventListener("click", () => {
          const text = (pageTexts && pageTexts[2]) || "";
          if (!text) {
            if (page3ExtractOutput7102)
              page3ExtractOutput7102.textContent =
                "[no text available for page 3]";
            return;
          }

          // Normalize CR chars and prepare for case-insensitive searches
          const normalized = text.replace(/\r/gi, "");
          // match the exact structure: name, dash, 4998, asterisks, ending 7102
          const specificRegex = /CARLOS\s+A\s+S\s+VELOSO\s*-\s*4998\*+7102/i;
          const match = specificRegex.exec(normalized);
          if (!match) {
            if (page3ExtractOutput7102)
              page3ExtractOutput7102.textContent =
                "[pattern 4998****7102 not found on page 3]";
            return;
          }

          const startIndex = match.index;
          const afterMatch = normalized.substring(startIndex + match[0].length);
          const subtotalMatch = SUBTOTAL_REGEX.exec(afterMatch);
          let endIndex;
          if (subtotalMatch) {
            endIndex = startIndex + match[0].length + subtotalMatch.index;
          } else {
            endIndex = normalized.length;
          }

          const snippet = normalized.substring(startIndex, endIndex).trim();
          if (page3ExtractOutput7102)
            page3ExtractOutput7102.textContent =
              snippet || "[extracted snippet empty]";
          try {
            buildStructuredJSON();
          } catch (e) {
            console.error("buildStructuredJSON failed", e);
          }
        });
      }

      // Prompt password overlay. Returns a promise that resolves when user submits or cancels.
      function promptPassword(message) {
        return new Promise((resolve, reject) => {
          pwMessage.style.display = message ? "block" : "none";
          pwMessage.textContent = message || "";
          pwInput.value = "";
          pwOverlay.classList.remove("hidden");
          pwInput.focus();

          function cleanup() {
            pwOverlay.classList.add("hidden");
            pwForm.removeEventListener("submit", onSubmit);
            pwCancel.removeEventListener("click", onCancel);
          }

          async function onSubmit(ev) {
            ev.preventDefault();
            const password = pwInput.value || "";
            cleanup();
            setProgress("Retrying with password...");
            try {
              await tryOpenAndExtract(latestArrayBuffer, password);
              resolve();
            } catch (err) {
              // If that throws and indicates password again, prompt will reappear
              // but we handle that inside tryOpenAndExtract which calls promptPassword again.
              // For any unexpected error, show it and reject.
              const msg = (err && (err.message || err.toString())) || "";
              const needsPassword =
                /password/i.test(msg) ||
                (err && err.name === "PasswordException");
              if (!needsPassword) {
                output.textContent = "Error: " + msg;
                setProgress("Error opening PDF");
                reject(err);
              } else {
                // tryOpenAndExtract will itself call promptPassword('Incorrect ...')
                resolve();
              }
            }
          }

          function onCancel() {
            cleanup();
            setProgress("Password entry cancelled");
            resolve();
          }

          pwForm.addEventListener("submit", onSubmit);
          pwCancel.addEventListener("click", onCancel);
        });
      }

      async function extractAllText(pdf) {
        extractedText = "";
        const num = pdf.numPages;
        for (let i = 1; i <= num; i++) {
          setProgress(`Extracting page ${i} / ${num}...`);
          try {
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            const strings = content.items.map((item) => item.str);
            const pageText = strings.join(" ");
            // store per-page text for single-page display
            pageTexts[i - 1] = pageText;
            if (i === 3) {
              // update page 3 area as soon as it's available
              page3Output.textContent = pageText || "[page 3 has no text]";
              showPage3Btn.disabled = false;
              if (extractPage3Btn) extractPage3Btn.disabled = false;
              if (page3ExtractOutput)
                page3ExtractOutput.textContent = "No snippet extracted yet.";
              // automatically run the snippet extractions for page 3
              try {
                extractSnippet2091FromText(pageText);
              } catch (e) {
                console.error("auto extract default failed", e);
              }
              try {
                extractSnippet7102FromText(pageText);
              } catch (e) {
                console.error("auto extract 7102 failed", e);
              }
              try {
                buildStructuredJSON();
              } catch (e) {
                console.error("buildStructuredJSON failed", e);
              }
            }
            extractedText += `\n\n--- Page ${i} ---\n\n` + pageText;
            // write partial results to UI so user sees progress
            output.textContent = extractedText;
          } catch (err) {
            console.error("Error extracting page", i, err);
            extractedText += `\n\n--- Page ${i} [error extracting] ---\n\n`;
          }
        }
        // enable page 3 button if PDF has at least 3 pages
        if (num >= 3) {
          showPage3Btn.disabled = false;
          if (extractPage3Btn) extractPage3Btn.disabled = false;
          // if pageTexts[2] exists, copy it to the display; otherwise show placeholder
          page3Output.textContent =
            pageTexts[2] || "Page 3 will appear here when extracted.";
        }
      }

      // Keyboard: Escape in password overlay cancels
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && !pwOverlay.classList.contains("hidden")) {
          pwCancel.click();
        }
      });
    </script>
  </body>
</html>
