<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Browser PDF Text Extractor (pdf.js)</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          Arial;
        margin: 24px;
      }
      .controls {
        margin-bottom: 12px;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .btn {
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #f7f7f7;
      }
      .btn.primary {
        background: #0070f3;
        color: white;
        border-color: #005ac1;
      }
      #output {
        white-space: pre-wrap;
        background: #111;
        color: #eee;
        padding: 12px;
        border-radius: 6px;
        min-height: 200px;
        overflow: auto;
      }
      #progress {
        font-size: 0.95rem;
        color: #333;
      }
      .password-overlay {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
      }
      .pw-box {
        background: white;
        padding: 18px;
        border-radius: 8px;
        width: 320px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
      }
      .pw-box label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
      }
      .pw-box input {
        width: 100%;
        padding: 8px;
        margin-bottom: 8px;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>Browser PDF Text Extractor (pdf.js)</h1>
    <p>
      Upload a PDF file. If it is password-protected, you'll be asked for the
      password. Extraction runs entirely in the browser.
    </p>

    <div class="controls">
      <input id="file-input" type="file" accept="application/pdf" />
      <button id="extract-btn" class="btn primary">Extract Text</button>
      <button id="download-btn" class="btn" disabled>Download .txt</button>
      <button id="show-page3-btn" class="btn" disabled>Show Page 3</button>
      <span id="progress">Ready</span>
    </div>

    <div id="output" aria-live="polite">No text extracted yet.</div>

    <!-- Dedicated area to display only the content of page 3 -->
    <h3>Page 3</h3>
    <div
      id="page3-output"
      aria-live="polite"
      style="
        white-space: pre-wrap;
        background: #fff;
        color: #111;
        padding: 12px;
        border-radius: 6px;
        min-height: 120px;
        border: 1px solid #ddd;
      "
    >
      No page 3 content yet.
    </div>

    <!-- Password prompt overlay (hidden until needed) -->
    <div
      id="password-overlay"
      class="password-overlay hidden"
      role="dialog"
      aria-modal="true"
    >
      <div class="pw-box">
        <form id="password-form">
          <label for="pdf-password">PDF Password</label>
          <input
            id="pdf-password"
            type="password"
            autocomplete="current-password"
          />
          <div style="display: flex; gap: 8px; justify-content: flex-end">
            <button type="button" id="pw-cancel" class="btn">Cancel</button>
            <button type="submit" class="btn primary">Submit</button>
          </div>
          <p
            id="pw-message"
            style="
              color: #b00020;
              margin-top: 8px;
              font-size: 0.95rem;
              display: none;
            "
          ></p>
        </form>
      </div>
    </div>

    <!-- pdf.js from CDN (use jsDelivr to avoid MIME/type issues when opening file://) -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist/build/pdf.min.js"></script>
    <script>
      // Simple, self-contained PDF text extractor using pdf.js in the browser.
      // Works with password-protected PDFs: detects password requirement and prompts user.

      const fileInput = document.getElementById("file-input");
      const extractBtn = document.getElementById("extract-btn");
      const progressEl = document.getElementById("progress");
      const output = document.getElementById("output");
      const downloadBtn = document.getElementById("download-btn");

      const pwOverlay = document.getElementById("password-overlay");
      const pwForm = document.getElementById("password-form");
      const pwInput = document.getElementById("pdf-password");
      const pwCancel = document.getElementById("pw-cancel");
      const pwMessage = document.getElementById("pw-message");

      // point workerSrc to the CDN worker file (use jsDelivr to avoid MIME issues)
      if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdn.jsdelivr.net/npm/pdfjs-dist/build/pdf.worker.min.js";
      } else {
        console.error("pdfjsLib not found. Library failed to load.");
        // show a user-friendly message and disable interaction
        document.getElementById("progress").textContent =
          "Failed to load pdf.js library. See console for details.";
        const btn = document.getElementById("extract-btn");
        if (btn) btn.disabled = true;
      }

      let latestArrayBuffer = null;
      let extractedText = "";
      // Store text per page so we can show a single page (page 3) on demand
      let pageTexts = [];
      const showPage3Btn = document.getElementById("show-page3-btn");
      const page3Output = document.getElementById("page3-output");

      function setProgress(text) {
        progressEl.textContent = text;
      }

      fileInput.addEventListener("change", (e) => {
        extractedText = "";
        pageTexts = [];
        downloadBtn.disabled = true;
        showPage3Btn.disabled = true;
        page3Output.textContent = "No page 3 content yet.";
        output.textContent = "No text extracted yet.";
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        if (
          f.type !== "application/pdf" &&
          !f.name.toLowerCase().endsWith(".pdf")
        ) {
          alert("Please select a PDF file.");
          fileInput.value = "";
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          latestArrayBuffer = reader.result;
          setProgress(
            `Loaded file ${f.name} (${Math.round(f.size / 1024)} KB)`,
          );
        };
        reader.onerror = () => {
          setProgress("Error reading file");
        };
        reader.readAsArrayBuffer(f);
      });

      extractBtn.addEventListener("click", async () => {
        if (!latestArrayBuffer) {
          alert("No PDF selected.");
          return;
        }
        extractedText = "";
        pageTexts = [];
        showPage3Btn.disabled = true;
        output.textContent = "Extracting...";
        setProgress("Starting extraction...");

        try {
          await tryOpenAndExtract(latestArrayBuffer);
        } catch (err) {
          console.error(err);
          setProgress("Extraction failed");
          output.textContent =
            "Error: " + (err && err.message ? err.message : String(err));
        }
      });

      downloadBtn.addEventListener("click", () => {
        const blob = new Blob([extractedText], {
          type: "text/plain;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "extracted-text.txt";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      // Show only page 3 content when clicked
      showPage3Btn.addEventListener("click", () => {
        if (pageTexts && pageTexts.length >= 3) {
          page3Output.textContent = pageTexts[2] || "[page 3 has no text]";
        } else if (pageTexts && pageTexts.length > 0) {
          page3Output.textContent = "[page 3 not available in this PDF]";
        } else {
          page3Output.textContent = "[no extracted pages yet]";
        }
      });

      // Core flow: try opening with no password, if password required show prompt and retry.
      async function tryOpenAndExtract(arrayBuffer, providedPassword) {
        setProgress("Opening PDF...");
        // Create a fresh copy of the ArrayBuffer for pdf.js to consume.
        // pdf.js may transfer (and therefore detach) an ArrayBuffer when using a worker;
        // passing a copy prevents the original buffer from becoming detached and
        // allows retrying (e.g. after an incorrect password) without re-reading the file.
        const uint8 = new Uint8Array(arrayBuffer);
        const dataCopy = uint8.slice().buffer; // slice() creates a new copy
        const loadingTask = pdfjsLib.getDocument({
          data: dataCopy,
          password: providedPassword,
        });

        try {
          const pdf = await loadingTask.promise;
          setProgress(
            `PDF opened — ${pdf.numPages} page(s). Extracting text...`,
          );
          await extractAllText(pdf);
          setProgress("Extraction complete");
          output.textContent = extractedText || "[no text found]";
          downloadBtn.disabled = extractedText.length === 0;
          return;
        } catch (err) {
          // pdf.js uses PasswordException when PDF requires or rejects a password.
          // The error may contain 'Password' in its message; check robustly.
          const msg = (err && (err.message || err.toString())) || "";
          const needsPassword =
            /password/i.test(msg) || (err && err.name === "PasswordException");
          if (needsPassword) {
            // If user already provided a password, it must be incorrect.
            if (providedPassword) {
              await promptPassword("Incorrect password — please try again");
              return; // prompt handler will call tryOpenAndExtract again
            }
            // Show prompt to ask for password
            await promptPassword();
            return; // prompt handler will continue
          }
          // Other errors: rethrow
          throw err;
        }
      }

      // Prompt password overlay. Returns a promise that resolves when user submits or cancels.
      function promptPassword(message) {
        return new Promise((resolve, reject) => {
          pwMessage.style.display = message ? "block" : "none";
          pwMessage.textContent = message || "";
          pwInput.value = "";
          pwOverlay.classList.remove("hidden");
          pwInput.focus();

          function cleanup() {
            pwOverlay.classList.add("hidden");
            pwForm.removeEventListener("submit", onSubmit);
            pwCancel.removeEventListener("click", onCancel);
          }

          async function onSubmit(ev) {
            ev.preventDefault();
            const password = pwInput.value || "";
            cleanup();
            setProgress("Retrying with password...");
            try {
              await tryOpenAndExtract(latestArrayBuffer, password);
              resolve();
            } catch (err) {
              // If that throws and indicates password again, prompt will reappear
              // but we handle that inside tryOpenAndExtract which calls promptPassword again.
              // For any unexpected error, show it and reject.
              const msg = (err && (err.message || err.toString())) || "";
              const needsPassword =
                /password/i.test(msg) ||
                (err && err.name === "PasswordException");
              if (!needsPassword) {
                output.textContent = "Error: " + msg;
                setProgress("Error opening PDF");
                reject(err);
              } else {
                // tryOpenAndExtract will itself call promptPassword('Incorrect ...')
                resolve();
              }
            }
          }

          function onCancel() {
            cleanup();
            setProgress("Password entry cancelled");
            resolve();
          }

          pwForm.addEventListener("submit", onSubmit);
          pwCancel.addEventListener("click", onCancel);
        });
      }

      async function extractAllText(pdf) {
        extractedText = "";
        const num = pdf.numPages;
        for (let i = 1; i <= num; i++) {
          setProgress(`Extracting page ${i} / ${num}...`);
          try {
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            const strings = content.items.map((item) => item.str);
            const pageText = strings.join(" ");
            // store per-page text for single-page display
            pageTexts[i - 1] = pageText;
            if (i === 3) {
              // update page 3 area as soon as it's available
              page3Output.textContent = pageText || "[page 3 has no text]";
              showPage3Btn.disabled = false;
            }
            extractedText += `\n\n--- Page ${i} ---\n\n` + pageText;
            // write partial results to UI so user sees progress
            output.textContent = extractedText;
          } catch (err) {
            console.error("Error extracting page", i, err);
            extractedText += `\n\n--- Page ${i} [error extracting] ---\n\n`;
          }
        }
        // enable page 3 button if PDF has at least 3 pages
        if (num >= 3) {
          showPage3Btn.disabled = false;
          // if pageTexts[2] exists, copy it to the display; otherwise show placeholder
          page3Output.textContent =
            pageTexts[2] || "Page 3 will appear here when extracted.";
        }
      }

      // Keyboard: Escape in password overlay cancels
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && !pwOverlay.classList.contains("hidden")) {
          pwCancel.click();
        }
      });
    </script>
  </body>
</html>
